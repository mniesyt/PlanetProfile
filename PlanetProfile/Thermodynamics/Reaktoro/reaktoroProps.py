import timefrom PlanetProfile.Thermodynamics.Reaktoro.sigmaElectricMcCleskey2012 import elecCondMcCleskey2012from PlanetProfile.Thermodynamics.Reaktoro.reaktoroPropsHelperFunctions import *from PlanetProfile import _ROOTfrom PlanetProfile.Utilities.defineStructs import Constants, EOSlist, CustomSolutionParamsStructfrom hdf5storage import loadmat, savematfrom PlanetProfile.Utilities.DataManip import ResetNearestExtrap, ReturnConstantPTwfrom collections.abc import Iterablefrom scipy.interpolate import RegularGridInterpolatorfrom scipy.optimize import root_scalar as GetZerofrom itertools import repeat# Assign loggerlog = logging.getLogger('PlanetProfile')# Obtain variable that will hold Reaktoro ParamsReaktoroParams = CustomSolutionParamsStruct()def FileSetupFromConfig(CustomSolutionParams):    """ Check CustomSolutionConfig inputs are valid, set file paths, and save global reference to object so Rkt file can use    """    # Ensure frezchem database is valid    CustomSolutionParams.setPaths(_ROOT)    for file_name in os.listdir(CustomSolutionParams.databasePath):        if file_name == CustomSolutionParams.FREZCHEM_DATABASE:            break    else:        log.warning(            "Input frezchem database does not match any of the available saved files.\nCheck that the input is properly spelled and has .dat at end. Using default frezchem.dat file")        CustomSolutionParams.FREZCHEM_DATABASE = "frezchem.dat"    # Check the unit is 'g' or 'mol' (g - grams, mol - mols)    if not CustomSolutionParams.SPECIES_CONCENTRATION_UNIT == "g" and not CustomSolutionParams.SPECIES_CONCENTRATION_UNIT == "mol":        log.warning(            "Input species concentration unit is not valid. Check that it is either g or mol. Using mol as default")        CustomSolutionParams.SPECIES_CONCENTRATION_UNIT = "mol"    # Internally save the relevant CustomSolutionParameters to ReaktoroParams object so they can be used by Reaktoro file    for attr, value in CustomSolutionParams.__dict__.items():        setattr(ReaktoroParams, attr, value)    return CustomSolutionParamsdef CustomSolutionPlanetSetup(Planet, Params):    """    Setup Reaktoro settings and try to Load EOS for Planet with given Ocean comp and w_ppt (if not 0), ensuring that these EOS have been generated and written to disk.    Especially useful to prevent simultaenous writing in InductoGram.    Args:    Returns:    """    FileSetupFromConfig(Params.CustomSolution)    w_ppt = Planet.Ocean.wOcean_ppt    ocean_string = Planet.Ocean.comp    Planet.Ocean.comp, Planet.Ocean.wOcean_ppt = w_ppt_calculator(ocean_string, w_ppt)    aqueous_species_string, speciation_ratio_per_kg, EOS_label = SpeciesParser(Planet.Ocean.comp)    try:        EOSLookupTableLoader(aqueous_species_string, speciation_ratio_per_kg, EOS_label)    except:        raise ValueError("EOS Lookup Table for thermodynamic properties and/or phase equilibria could not be generated. Check that input species\n"                         +" is a reasonable species input (i.e. correct format, species exists in Frezchem/Supcrt, reasonable ratios)")    return Planet, Paramsdef w_ppt_calculator(ocean_species_string, w_ppt):    '''    Calculates the absolute ratio to match the input w_ppt, or if w_ppt is zero, then calculate the w_ppt that corresponds to the input speciation    Args:        species_string_with_ratios:        w_ppt: desired w_ppt    Returns:    '''    CustomSolutionLabel = ocean_species_string.split('=')[0].strip()    aqueous_species_string, speciation_ratio_per_kg, EOS_label = SpeciesParser(ocean_species_string)    # If ratios are in mol/kg, convert to gram/kg    # Sum up total amount of mass in grams    total_solute_mass_g = 0    for species, species_per_ratio in speciation_ratio_per_kg.items():        if species != "H2O":            if ReaktoroParams.SPECIES_CONCENTRATION_UNIT == 'mol':                species_molar_mass_g_mol = rkt.Species(species).molarMass() * 1000                species_gram_ratio = species_molar_mass_g_mol * species_per_ratio                speciation_ratio_per_kg[species] = species_gram_ratio            else:                species_gram_ratio = species_per_ratio            total_solute_mass_g += species_gram_ratio    # TEMPORARY FIX TO W_PPT CALCULATION BEING NOT INTUITIVE AND NOT COMPATIBLE WITH RELOAD FROM DISK    if w_ppt == 0 or w_ppt > 0:        return ocean_species_string, total_solute_mass_g    # Otherwise, adjust ocean_species_string so it corresponds to input w_ppt    else:        # Find the common ratio to get to w_ppt        common_ratio = w_ppt / total_solute_mass_g        # Multiply every value in dictionary by common_ratio        absolute_speciation_values_per_kg = {key: value * common_ratio for key, value in speciation_ratio_per_kg.items() if                                             key != "H2O"}        log.info(f'Total solute mass after calculating to match w_ppt is {sum(absolute_speciation_values_per_kg.values())}')        # Rebuild the species_string        final_species_string = ''        for species, species_ratio in absolute_speciation_values_per_kg.items():            if ReaktoroParams.SPECIES_CONCENTRATION_UNIT == 'mol':                species_molar_mass_g_mol = rkt.Species(species).molarMass() * 1000                species_ratio = species_ratio * (1 / species_molar_mass_g_mol)            final_species_string += f'{species}: {species_ratio}, '        return (CustomSolutionLabel + ' = ' + final_species_string.rstrip(', ')), w_ppt"""def EOS_Delta_Finder(EOS_lookup_label):    fLookup = os.path.join(ReaktoroParams.rktPath, 'CustomSolutionLookupTables', f'props_{EOS_lookup_label}.mat')    if os.path.exists(fLookup):        fRktProps = loadmat(fLookup)        EOSdeltaP = np.maximum(np.round(np.mean(np.diff()), 2), 0.001)        self.EOSdeltaT = np.maximum(np.round(np.mean(np.diff(TRkt_K)), 2), 0.001)"""def RktProps(EOS_lookup_label, aqueous_species_string, speciation_ratio_per_kg, P_MPa, T_K, EXTRAP):    fn_RktProps = RktPropsLookup(EOS_lookup_label, aqueous_species_string, speciation_ratio_per_kg)    EOS_deltaP = fn_RktProps.EOSdeltaP    EOS_deltaT = fn_RktProps.EOSdeltaT    if not EXTRAP:        newP_MPa, newT_K = ResetNearestExtrap(P_MPa, T_K, fn_RktProps.Pmin, fn_RktProps.Pmax,                                              fn_RktProps.Tmin, fn_RktProps.Tmax)        if (not np.all(newP_MPa == P_MPa)) or (not np.all(newT_K == T_K)):            log.warning('Extrapolation is disabled for ocean fluids, and input EOS P and/or T ' +                        'extend beyond the EOS properties lookup table limits of [Pmin, Pmax] = ' +                        f'{fn_RktProps.Pmin}, {fn_RktProps.Pmax} MPa and [Tmin, Tmax] = ' +                        f'{fn_RktProps.Tmin}, {fn_RktProps.Tmax} K.')            P_MPa = np.unique(newP_MPa)            T_K = np.unique(newT_K)        # Ensure that P_MPa and T_K have at least 5 values in order to make rectbivariatespline        if np.size(T_K) < 5:            T_K = np.linspace(T_K[0], T_K[-1] + EOS_deltaT, 5)            EOS_deltaT = np.maximum(np.round(np.mean(np.diff(T_K)), 2), 0.001)        if np.size(P_MPa) < 5:            P_MPa = np.linspace(P_MPa[0], P_MPa[-1] + EOS_deltaP, 5)            EOS_deltaP = np.maximum(np.round(np.mean(np.diff(P_MPa)), 2), 0.001)    evalPts = fn_RktProps.fn_evalPts(P_MPa, T_K)    nPs = np.size(P_MPa)    # Interpolate the input data to get the values corresponding to the current ocean comp,    # then get the property values for the input (P,T) pairs and reshape to how they need    # to be formatted for use in the ocean EOS.    rho_kgm3 = np.reshape(fn_RktProps.fn_rho_kgm3(evalPts), (nPs, -1))    Cp_JkgK = np.reshape(fn_RktProps.fn_Cp_JkgK(evalPts), (nPs, -1))    alpha_pK = np.reshape(fn_RktProps.fn_alpha_pK(evalPts), (nPs, -1))    kTherm_WmK = fn_RktProps.fn_kTherm_WmK(P_MPa, T_K, 0, grid =True)    return P_MPa, T_K, rho_kgm3, Cp_JkgK, alpha_pK, kTherm_WmK, EOS_deltaP, EOS_deltaTclass RktPropsLookup:    def __init__(self, EOS_lookup_label, aqueous_species_string, speciation_ratio_per_kg):        self.fLookup = os.path.join(ReaktoroParams.rktPath, 'CustomSolutionLookupTables',                                    f'props_{EOS_lookup_label}.mat')        if self.fLookup in EOSlist.loaded.keys():            log.debug(f'EOS properties lookup table with label {EOS_lookup_label} already loaded.')            self.fn_rho_kgm3, self.fn_Cp_JkgK, self.fn_alpha_pK, self.fn_kTherm_WmK, self.fn_VP_kms, self.fn_KS_GPa, self.fn_mu_J_mol, self.fn_evalPts = \            EOSlist.loaded[self.fLookup]            self.Pmin, self.Pmax, self.EOSdeltaP, self.Tmin, self.Tmax, self.EOSdeltaT = EOSlist.ranges[self.fLookup]        else:            EOSLookupTables = EOSLookupTableLoader(aqueous_species_string, speciation_ratio_per_kg, EOS_lookup_label)            fRktProps = EOSLookupTables.props_EOS            TRkt_K = fRktProps['T_K']            PRkt_MPa = fRktProps['P_MPa']            self.fn_rho_kgm3 = RegularGridInterpolator((PRkt_MPa, TRkt_K), fRktProps['rho'], method='linear',                                                       bounds_error=False, fill_value=None)            self.fn_Cp_JkgK = RegularGridInterpolator((PRkt_MPa, TRkt_K), fRktProps['Cp'], method='linear',                                                      bounds_error=False, fill_value=None)            self.fn_alpha_pK = RegularGridInterpolator((PRkt_MPa, TRkt_K), fRktProps['alpha'], method='linear',                                                       bounds_error=False, fill_value=None)            self.fn_VP_kms = RegularGridInterpolator((PRkt_MPa, TRkt_K), fRktProps['VP'], method='linear',                                                     bounds_error=False, fill_value=None)            self.fn_KS_GPa = RegularGridInterpolator((PRkt_MPa, TRkt_K), fRktProps['KS'], method='linear',                                                     bounds_error=False, fill_value=None)            self.fn_mu_J_mol = RegularGridInterpolator((PRkt_MPa, TRkt_K), fRktProps['mu'], method='linear',                                                       bounds_error=False, fill_value=None)            self.fn_kTherm_WmK = ReturnConstantPTw(const=Constants.kThermWater_WmK)            self.Pmin = np.min(PRkt_MPa)            self.Pmax = np.max(PRkt_MPa)            self.EOSdeltaP = np.maximum(np.round(np.mean(np.diff(PRkt_MPa)), 2), 0.001)            self.Tmin = np.min(TRkt_K)            self.Tmax = np.max(TRkt_K)            self.EOSdeltaT = np.maximum(np.round(np.mean(np.diff(TRkt_K)), 2), 0.001)            self.fn_kTherm_WmK = ReturnConstantPTw(const=Constants.kThermWater_WmK)            # Save functions to EOSlist so they can be referenced in future            EOSlist.loaded[self.fLookup] = (                self.fn_rho_kgm3, self.fn_Cp_JkgK, self.fn_alpha_pK, self.fn_kTherm_WmK, self.fn_VP_kms, self.fn_KS_GPa,                self.fn_mu_J_mol, self.fn_evalPts)            EOSlist.ranges[self.fLookup] = (self.Pmin, self.Pmax, self.EOSdeltaP, self.Tmin, self.Tmax, self.EOSdeltaT)    def fn_evalPts(self, Pin_MPa, Tin_K):        P_MPa = ensureArray(Pin_MPa)        T_K = ensureArray(Tin_K)        P_Mesh, T_Mesh = np.meshgrid(P_MPa, T_K, indexing='ij')        out = np.column_stack((P_Mesh.ravel(), T_Mesh.ravel()))        return np.array(out)class SeafreezePureWaterCorrector:    def __init__(self):        # Obtain internal aqueous chemical potential correction spline (generating one if necessary)        spline_path = os.path.join(ReaktoroParams.rktPath, 'Reaktoro_Saved_Files',                                   'seafreeze_pure_water_correction.mat')        if os.path.exists(spline_path):            correction_data = loadmat(spline_path)            supcrt_P_MPa = correction_data['Supcrt_P_MPa']            supcrt_T_K = correction_data['Supcrt_T_K']            delta_rho = correction_data['density_difference']            delta_Cp = correction_data['isobaric_heat_capacity_difference']            delta_alpha = correction_data['thermal_expansivity_difference']            delta_VP = correction_data['sound_speed_difference']            delta_KS = correction_data['bulk_modulus_difference']            delta_mu = correction_data['chemical_potential_difference']            frezchem_P_MPa = correction_data['frezchem_P_MPa']            delta_freezing_temp = correction_data['freezing_temperature_difference']        # This file will be uploaded to Github, so user should not need to generate this data        else:            log.warning('The Seafreeze pure water correction data is not available on disk. We will generate this data and save to disk so it can be called in the future.')            frezchem_P_MPa, delta_freezing_temp = self.FrezchemCorrectionData()            supcrt_P_MPa, supcrt_T_K, delta_rho, delta_Cp, delta_alpha, delta_VP, delta_KS, delta_mu = self.SupcrtSeafreezeCorrectionData()            SupcrtSeafreezeCorrectionData = {'Supcrt_P_MPa': supcrt_P_MPa, 'Supcrt_T_K': supcrt_T_K,                                                                  'density_difference': delta_rho,                                             'isobaric_heat_capacity_difference': delta_Cp,                                             'thermal_expansivity_difference': delta_alpha,                                             'sound_speed_difference': delta_VP,                                             'bulk_modulus_difference': delta_KS,                                             'chemical_potential_difference': delta_mu,                                             'frezchem_P_MPa': frezchem_P_MPa,                                             'freezing_temperature_difference': delta_freezing_temp}            savemat(spline_path, SupcrtSeafreezeCorrectionData)        self.fn_rho_correction = RegularGridInterpolator((supcrt_P_MPa, supcrt_T_K), delta_rho, method = 'linear', bounds_error = False, fill_value = None)        self.fn_Cp_correction = RegularGridInterpolator((supcrt_P_MPa, supcrt_T_K), delta_Cp, method='linear', bounds_error=False,                                                        fill_value=None)        self.fn_alpha_correction = RegularGridInterpolator((supcrt_P_MPa, supcrt_T_K), delta_alpha, method='linear',                                                           bounds_error=False, fill_value=None)        self.fn_VP_correction = RegularGridInterpolator((supcrt_P_MPa, supcrt_T_K), delta_VP, method='linear', bounds_error=False,                                                        fill_value=None)        self.fn_KS_correction = RegularGridInterpolator((supcrt_P_MPa, supcrt_T_K), delta_KS, method='linear', bounds_error=False,                                                        fill_value=None)        self.fn_mu_correction = RegularGridInterpolator((supcrt_P_MPa, supcrt_T_K), delta_mu, method='linear', bounds_error=False,                                                        fill_value=None)        self.fn_freezing_temp_correction = RegularGridInterpolator((frezchem_P_MPa,), delta_freezing_temp,                                                           method='linear', bounds_error=False, fill_value=None)    def FrezchemCorrectionData(self):        def whichphaseChooser(P, T):            PT = np.empty((1,), dtype='object')            PT[0] = (P, T)            return sfz.whichphase(PT)[0]        eos_P_MPa = np.linspace(0.1, 200, 200)        sfz_T_freezing = []        for P in eos_P_MPa:            phaseChange = lambda T: 0.5 - (1 - int(whichphaseChooser(P, T) > 0))            Tfreeze_K = GetZero(phaseChange, bracket=[240, 280]).root            sfz_T_freezing.append(Tfreeze_K)        sfz_T_freezing = np.array(sfz_T_freezing)        # Obtain frezchem freezing temperatures        rkt_T_freezing = []        aqueous_species_list = 'H+ OH- H2O'        speciation_ratio_mol_kg = {'H2O': float(1 / rkt.waterMolarMass)}        frezchem_file_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'Databases', 'frezchem.dat')        frezchem = PhreeqcGeneratorForChemicalConstraint(aqueous_species_list, speciation_ratio_mol_kg, "mol",                                                         frezchem_file_path)        db, system, state, conditions, solver, props = frezchem        state = rkt.ChemicalState(state)        # Create an iterator to go through P_MPa        it = np.nditer([eos_P_MPa])        conditions.set("IP", 0.1)        conditions.setLowerBoundTemperature(240, "K")        conditions.setUpperBoundTemperature(280, "K")        for P in it:            P = float(P)            conditions.pressure(P, "MPa")            # Solve the equilibrium problem            result = solver.solve(state, conditions)            if not result.succeeded():                print("HELLO")            # Update the properties            props.update(state)            # Obtain the equilibrium temperature            rkt_T_freezing.append(float(props.temperature()))            # Reset the state            state = reset_state(system, speciation_ratio_mol_kg, "mol")        rkt_T_freezing = np.array(rkt_T_freezing)        # Find difference in freezing temperatures        difference_in_T_freezings = rkt_T_freezing - sfz_T_freezing        return eos_P_MPa, difference_in_T_freezings    def SupcrtSeafreezeCorrectionData(self):        """ Obtain the aqueous H2O thermodynamic differnce of pure water for Supcrt and Seafreeze across a 2-D grid of pressure and temperatures."""        P_MPa = np.linspace(Constants.RktPmin_MPa, Constants.EOSPmax_MPa, 500)        T_K = np.linspace(Constants.SupcrtTmin_K, Constants.SupcrtTmax_K, 200)        P_MPa_supcrt = np.linspace(Constants.RktPmin_MPa, Constants.SupcrtPmax_MPa, 500)        PT = np.array([P_MPa, T_K], dtype = object)        out = sfz.getProp(PT, 'water1')        sfz_rho = out.rho        sfz_Cp = out.Cp        sfz_alpha = out.alpha        sfz_VP = out.vel * 1e-3        sfz_KS = out.Ks * 1e-3        sfz_mu = out.G * rkt.waterMolarMass # Multiply Gibbs free energy by molar mass of H2O to get chemical potential of pure water        rkt_rho = []        rkt_Cp = []        rkt_alpha = []        rkt_VP = []        rkt_KS = []        rkt_mu = []        aqueous_species_list = 'H+ OH- H2O(aq)'        speciation_ratio_mol_kg = {'H2O(aq)': float(1 / rkt.waterMolarMass)}        supcrt = SupcrtGenerator(aqueous_species_list, speciation_ratio_mol_kg, "mol", "supcrt16", True, None)        db, system, state, conditions, solver, props = supcrt        P_MPa_mesh, T_K_mesh = np.meshgrid(P_MPa_supcrt, T_K, indexing='ij')        # Create a nditer iterator        it = np.nditer([P_MPa_mesh, T_K_mesh], flags=['multi_index'])        # Go through each P, T combination        for P, T in it:            P = float(P)            T = float(T)            conditions.temperature(T, "K")            # Establish equilibrium pressure constraint value            conditions.pressure(P, "MPa")            # Solve the equilibrium problem            result = solver.solve(state, conditions)            if result.succeeded():                # Update the properties                props.update(state)                # Get the aqueous phase props                aqueousProps = props.phaseProps("AqueousPhase")                # Check if the equilibrium problem succeeded                rho_kgm3 = float(aqueousProps.density())                Cp_JKgK = float(aqueousProps.specificHeatCapacityConstP())                mu_J_mol = float(props.speciesChemicalPotential("H2O(aq)"))                # To calculate thermal coefficient, we will multiply inverse of specific volume by its                # partial derivative with respect to temperature                specific_volume_m3_kg = aqueousProps.specificVolume()                dSpecificVolumedT = aqueousProps.specificVolumeT()                thermalExpansivity_1_K = 1 / float(specific_volume_m3_kg) * float(dSpecificVolumedT)                # To calculate sound speed, obtain specific volume and pressure derivative of specific volume                specific_volume_m3_kg = float(aqueousProps.specificVolume())                pressure_derivative_specific_volume = float(aqueousProps.specificVolumeP())                # Calculate commpressibility factor, multiplying negative inverse of specific volume by pressure derivative of specific volume                k_compressibility = -(1 / specific_volume_m3_kg) * pressure_derivative_specific_volume                # Calculate sound speed, multiplying k by density and taking the product to the -0.5                c_m_s = (rho_kgm3 * k_compressibility) ** (-0.5)                # Convert to km/s                c_km_s = c_m_s / 1000                # Calculate KS                KS_GPa = rho_kgm3 * float(c_km_s) ** 2 * 1e-3            else:                rho_kgm3 = np.nan                Cp_JKgK = np.nan                mu_J_mol = np.nan                thermalExpansivity_1_K = np.nan                c_km_s = np.nan                KS_GPa = np.nan            rkt_rho.append(rho_kgm3)            rkt_Cp.append(Cp_JKgK)            rkt_mu.append(mu_J_mol)            rkt_alpha.append(thermalExpansivity_1_K)            rkt_VP.append(float(c_km_s))            rkt_KS.append(float(KS_GPa))            state = reset_state(system, speciation_ratio_mol_kg, "mol")        # Turn the list into a 2d array        rkt_rho = np.array(rkt_rho).reshape((P_MPa_supcrt.size, -1))        rkt_Cp = np.array(rkt_Cp).reshape((P_MPa_supcrt.size, -1))        rkt_alpha = np.array(rkt_alpha).reshape((P_MPa_supcrt.size, -1))        rkt_VP = np.array(rkt_VP).reshape((P_MPa_supcrt.size, -1))        rkt_KS = np.array(rkt_KS).reshape((P_MPa_supcrt.size, -1))        rkt_mu = np.array(rkt_mu).reshape((P_MPa_supcrt.size, -1))        # Create RegularGridInterpolators and cubic extrapolate up to 2000MPa        fn_rkt_rho = RegularGridInterpolator((P_MPa_supcrt, T_K), rkt_rho, method='linear', bounds_error=False,                                         fill_value=None)        fn_rkt_Cp = RegularGridInterpolator((P_MPa_supcrt, T_K), rkt_Cp, method='linear', bounds_error=False,                                         fill_value=None)        fn_rkt_alpha = RegularGridInterpolator((P_MPa_supcrt, T_K), rkt_alpha, method='linear', bounds_error=False,                                            fill_value=None)        fn_rkt_VP = RegularGridInterpolator((P_MPa_supcrt, T_K), rkt_VP, method='linear', bounds_error=False,                                         fill_value=None)        fn_rkt_KS = RegularGridInterpolator((P_MPa_supcrt, T_K), rkt_KS, method='linear', bounds_error=False,                                         fill_value=None)        fn_rkt_mu = RegularGridInterpolator((P_MPa_supcrt, T_K), rkt_mu, method='linear', bounds_error=False,                                         fill_value=None)        # Get data points up to 2000MPa        P_MPa_mesh, T_K_mesh = np.meshgrid(P_MPa, T_K, indexing='ij')        evalPts = np.column_stack((P_MPa_mesh.ravel(), T_K_mesh.ravel()))        rkt_rho = fn_rkt_rho(evalPts).reshape(P_MPa_mesh.shape)        rkt_Cp = fn_rkt_Cp(evalPts).reshape(P_MPa_mesh.shape)        rkt_alpha = fn_rkt_alpha(evalPts).reshape(P_MPa_mesh.shape)        rkt_VP = fn_rkt_VP(evalPts).reshape(P_MPa_mesh.shape)        rkt_KS = fn_rkt_KS(evalPts).reshape(P_MPa_mesh.shape)        rkt_mu = fn_rkt_mu(evalPts).reshape(P_MPa_mesh.shape)        # Find difference between rkt and sfz        delta_rho = rkt_rho - sfz_rho        delta_Cp = rkt_Cp - sfz_Cp        delta_alpha = rkt_alpha - sfz_alpha        delta_VP = rkt_VP - sfz_VP        delta_KS = rkt_KS - sfz_KS        delta_mu = rkt_mu - sfz_mu        # Return        return P_MPa, T_K, delta_rho, delta_Cp, delta_alpha, delta_VP, delta_KS, delta_muclass RktSeismic:    def __init__(self, EOS_lookup_label, aqueous_species_string, speciation_ratio_per_kg, EXTRAP):        self.EXTRAP = EXTRAP        self.WARNED = False  # Track whether user has been warned about extrapolation        # Gets the RktPropsLookup again. This should be quick as we have already loaded it into EOSlist using RktProps called before        fn_RktProps = RktPropsLookup(EOS_lookup_label, aqueous_species_string, speciation_ratio_per_kg)        # Get pressure and temperature limits        self.Pmin = fn_RktProps.Pmin        self.Pmax = fn_RktProps.Pmax        self.Tmin = fn_RktProps.Tmin        self.Tmax = fn_RktProps.Tmax        # Reassign the functions so they can be referenced when object is called        self.fn_VP_kms = fn_RktProps.fn_VP_kms        self.fn_KS_GPa = fn_RktProps.fn_KS_GPa    def __call__(self, P_MPa, T_K, grid=False):        if not self.EXTRAP:            newP_MPa, newT_K = ResetNearestExtrap(P_MPa, T_K, self.Pmin, self.Pmax, self.Tmin, self.Tmax)            if (not np.all(newP_MPa == P_MPa)) or (not np.all(newT_K == T_K)):                if not self.WARNED:                    log.warning(                        'Extrapolation is disabled for ocean fluids, and input EOS P and/or T for seismic calculations ' +                        f'extend beyond the EOS properties lookup table limits of\n[Pmin, Pmax] = ' +                        f'{self.Pmin}, {self.Pmax} MPa and [Tmin, Tmax] = ' +                        f'{self.Tmin}, {self.Tmax} K. Will reset the inputs to stay within the ranges.')                    self.WARNED = True                P_MPa = newP_MPa                T_K = newT_K        if grid:            evalPts = tuple(np.meshgrid(P_MPa, T_K, indexing='ij'))        else:            evalPts = np.column_stack((P_MPa, T_K))        VP_kms = np.squeeze(self.fn_VP_kms(evalPts))        KS_GPa = np.squeeze(self.fn_KS_GPa(evalPts))        return VP_kms, KS_GPa    def fn_evalPts(self, Pin_MPa, Tin_K):        P_MPa = ensureArray(Pin_MPa)        T_K = ensureArray(Tin_K)        out = [[P, T] for P in P_MPa for T in T_K]        return np.array(out)class EOSLookupTableLoader():    def __init__(self, aqueous_species_string, speciation_ratio_per_kg, EOS_lookup_label):        props_fLookup = os.path.join(ReaktoroParams.rktPath, 'CustomSolutionLookupTables',                                    f'props_{EOS_lookup_label}.mat')        phase_fLookup = os.path.join(ReaktoroParams.rktPath, 'CustomSolutionLookupTables',                                    f'phase_{EOS_lookup_label}.mat')        if os.path.exists(props_fLookup) and os.path.exists(phase_fLookup):            self.props_EOS = loadmat(props_fLookup)            self.phase_EOS = loadmat(phase_fLookup)        else:            log.warning(                f'EOSlookup table with label {EOS_lookup_label} does not exist, so we will generate a property EOS.\n'                f'Namely, we will query Reaktoro with input pressures to find associated properties and save to disk.')            # Define lower and upper pressure limits and create pressure range to query over            Pmin = Constants.RktPmin_MPa            Pmax = Constants.FrezchemPmax_MPa            deltaP = ReaktoroParams.EOS_deltaP            nPs = round((Pmax - Pmin) / deltaP)            PRkt_MPa = np.linspace(Pmin, Pmax, nPs)            # Get freezing temperatures for pressure range calculated by Frezchem            TFreezing_K = self.RktFreezingTemperatureFinder(aqueous_species_string, speciation_ratio_per_kg, PRkt_MPa)            # Get Seafreeze correction            SeafreezePureWaterCorrectorFunctions = SeafreezePureWaterCorrector()            # Correct data            TFreezing_K = TFreezing_K - SeafreezePureWaterCorrectorFunctions.fn_freezing_temp_correction(PRkt_MPa)            # Load properties into dictionary and save to a .mat file            RktPhase_Dictionary = {'P_MPa': PRkt_MPa, 'TFreezing_K': TFreezing_K}            Tmin, Tmax, Pmin, Pmax_supcrt = self.PropsConstraintFinder(aqueous_species_string,                                                                                           speciation_ratio_per_kg)            EOSdeltaP = ReaktoroParams.EOS_deltaP            EOSdeltaT = ReaktoroParams.EOS_deltaT            Pmax = Constants.EOSPmax_MPa            log.warning(                f'Input EOS will span from [Pmin, Pmax] = {Pmin}, {Pmax_supcrt} MPa by a step of {EOSdeltaP}\n'                f'and [Tmin, Tmax] = {Tmin}, {Tmax} K by a step of {EOSdeltaT}. This data will be linearly extrapolated up to {Pmax} MPa and then have a pure water correction applied to its data')            nTs = round((Tmax - Tmin) / EOSdeltaT)            nPs = round((Pmax_supcrt - Pmin) / EOSdeltaP)            nPs_extra = round((Pmax - (                        Pmax_supcrt + Constants.EOSdeltaP_For_Extrapolation)) / Constants.EOSdeltaP_For_Extrapolation)            TRkt_K = np.linspace(Tmin, Tmax, nTs)            PRkt_MPa = np.linspace(Pmin, Pmax_supcrt, nPs)            PExtrap_MPa = np.linspace(Pmax_supcrt + Constants.EOSdeltaP_For_Extrapolation, Pmax, nPs_extra)            P_MPa = np.concatenate((PRkt_MPa, PExtrap_MPa))            # Obtain properties from Reaktoro            start_time = time.time()            rho_kgm3, Cp_JKgK, alpha_pK, VP_kms, mu_J_mol = self.RktProps(aqueous_species_string,                                                                          speciation_ratio_per_kg, PRkt_MPa, TRkt_K,                                                                          "supcrt16")            end_time = time.time()            log.debug(f'Calculations took {end_time - start_time} seconds long')            # Calculate bulk modulus from sound speed            KS_GPa = rho_kgm3 * VP_kms ** 2 * 1e-3            # Load data into linear functions            ufn_rho_kgm3 = RegularGridInterpolator((PRkt_MPa, TRkt_K), rho_kgm3, method='linear',                                                   bounds_error=False, fill_value=None)            ufn_Cp_JkgK = RegularGridInterpolator((PRkt_MPa, TRkt_K), Cp_JKgK, method='linear',                                                  bounds_error=False, fill_value=None)            ufn_alpha_pK = RegularGridInterpolator((PRkt_MPa, TRkt_K), alpha_pK, method='linear',                                                   bounds_error=False, fill_value=None)            ufn_VP_kms = RegularGridInterpolator((PRkt_MPa, TRkt_K), VP_kms, method='linear',                                                 bounds_error=False, fill_value=None)            ufn_KS_GPa = RegularGridInterpolator((PRkt_MPa, TRkt_K), KS_GPa, method='linear',                                                 bounds_error=False, fill_value=None)            ufn_mu_J_mol = RegularGridInterpolator((PRkt_MPa, TRkt_K), mu_J_mol, method='linear',                                                   bounds_error=False, fill_value=None)            # Extrapolate up to Constants.EOSPmax_MPa            P_MPa_extrap_mesh, T_K_extrap_mesh = np.meshgrid(PExtrap_MPa, TRkt_K, indexing='ij')            extrapEvalPts = np.column_stack((P_MPa_extrap_mesh.ravel(), T_K_extrap_mesh.ravel()))            rho_kgm3 = np.concatenate((rho_kgm3, ufn_rho_kgm3(extrapEvalPts).reshape(P_MPa_extrap_mesh.shape)))            Cp_JKgK = np.concatenate((Cp_JKgK, ufn_Cp_JkgK(extrapEvalPts).reshape(P_MPa_extrap_mesh.shape)))            alpha_pK = np.concatenate((alpha_pK, ufn_alpha_pK(extrapEvalPts).reshape(P_MPa_extrap_mesh.shape)))            VP_kms = np.concatenate((VP_kms, ufn_VP_kms(extrapEvalPts).reshape(P_MPa_extrap_mesh.shape)))            KS_GPa = np.concatenate((KS_GPa, ufn_KS_GPa(extrapEvalPts).reshape(P_MPa_extrap_mesh.shape)))            mu_J_mol = np.concatenate((mu_J_mol, ufn_mu_J_mol(extrapEvalPts).reshape(P_MPa_extrap_mesh.shape)))            # Get Seafreeze correction            P_MPa_mesh, T_K_mesh = np.meshgrid(P_MPa, TRkt_K, indexing='ij')            evalPts = np.column_stack((P_MPa_mesh.ravel(), T_K_mesh.ravel()))            SeafreezePureWaterCorrectorFunctions = SeafreezePureWaterCorrector()            # Correct data            rho_kgm3 = rho_kgm3 - SeafreezePureWaterCorrectorFunctions.fn_rho_correction(evalPts).reshape(P_MPa_mesh.shape)            Cp_JKgK = Cp_JKgK - SeafreezePureWaterCorrectorFunctions.fn_Cp_correction(evalPts).reshape(P_MPa_mesh.shape)            alpha_pK = alpha_pK - SeafreezePureWaterCorrectorFunctions.fn_alpha_correction(evalPts).reshape(                P_MPa_mesh.shape)            VP_kms = VP_kms - SeafreezePureWaterCorrectorFunctions.fn_VP_correction(evalPts).reshape(                P_MPa_mesh.shape)            KS_GPa = KS_GPa - SeafreezePureWaterCorrectorFunctions.fn_KS_correction(evalPts).reshape(                P_MPa_mesh.shape)            mu_J_mol = mu_J_mol - SeafreezePureWaterCorrectorFunctions.fn_mu_correction(evalPts).reshape(                P_MPa_mesh.shape)            extrap_time = time.time() - end_time            log.debug(f'Extrap calculations took {extrap_time} seconds long')            # Load properties into a dictionary and save to a .mat file            RktProps_Dictionary = {'T_K': TRkt_K, 'P_MPa': P_MPa, 'rho': rho_kgm3, 'Cp': Cp_JKgK,                                   'alpha': alpha_pK, 'VP': VP_kms, 'KS': KS_GPa, 'mu': mu_J_mol}            savemat(phase_fLookup, RktPhase_Dictionary)            savemat(props_fLookup, RktProps_Dictionary)            self.props_EOS = loadmat(props_fLookup)            self.phase_EOS = loadmat(phase_fLookup)    def RktFreezingTemperatureFinder(self, aqueous_species_string, speciation_ratio_per_kg, P_MPa,                                     TMin_K=220, TMax_K=300,                                     significant_threshold=0.1):        """         Calculates the temperature at which the prescribed aqueous solution freezes. Utilizes the reaktoro framework to         constrain the equilibrium position at the prescribed pressure and the chemical potential difference between ice and liquid water at 0.1,          therefore calculating and returning the temperature (within the range) at which ice begins to form.         Parameters         ----------         speciation_ratio_per_kg: the ratio of species in the aqueous solution in mol/kg of water. Should be a dictionary         with the species as the key and its ratio as its value.         P_MPa: the desired equilibrium freezing pressure(s).         TMin_K: the lower limit of temperature that Reaktoro should query over         TMax_K: the upper limit of temperature that Reaktoro should query over         significant_threshold: the amount of moles of ice present for H2O to be considered in solid phase. Default is 1e-14 moles.         Returns         -------         t_freezing_K: the temperature at which the solution begins to freeze.         P_MPa_adjusted: adjusted pressure range that removes values that did not converge         """        # Disable chemical convergence warnings that Reaktoro raises. We handle these internally instead and throw more specific warnings when they appear.        # rkt.Warnings.disable(906)        # Create freezing temperatures list and indices of pressures to remove, if necessary        freezing_temperatures = []        # Create frezchem system        db, system, state, conditions, solver, props = PhreeqcGeneratorForChemicalConstraint(aqueous_species_string, speciation_ratio_per_kg,                                                         ReaktoroParams.SPECIES_CONCENTRATION_UNIT,                                                         ReaktoroParams.frezchemPath)        state = rkt.ChemicalState(state)        # Set conditions        conditions.set("IP", significant_threshold)        conditions.setLowerBoundTemperature(TMin_K, "K")        conditions.setUpperBoundTemperature(TMax_K, "K")        for index, P in enumerate(P_MPa):            P = float(P)            conditions.pressure(P, "MPa")            # Solve the equilibrium problem            result = solver.solve(state, conditions)            # Update the properties            props.update(state)            # Obtain the equilibrium temperature            equilibrium_temperature = props.temperature()            # Check if the result succeeded            if result.succeeded():                freezing_temperatures.append(float(equilibrium_temperature))                state = reset_state(system, speciation_ratio_per_kg, ReaktoroParams.SPECIES_CONCENTRATION_UNIT)            # If the result failed, then do not include this in list of freezing temperatures and remove from pressure list to avoid its use in creating spline            else:                log.debug(f'Failed to find freezing temperature at pressure {P} MPa when generating phase data from Frezchem. Will extrapolate this value.')                freezing_temperatures.append(np.nan)                state = reset_state(system, speciation_ratio_per_kg, ReaktoroParams.SPECIES_CONCENTRATION_UNIT)        freezing_temperatures = np.array(freezing_temperatures)        # Make interpolator for values that could converge        P_MPa_calculated = P_MPa[~np.isnan(freezing_temperatures)]        freezing_temperatures_calculated = freezing_temperatures[~np.isnan(freezing_temperatures)]        fn_frezchem_phaseRGI = RegularGridInterpolator((P_MPa_calculated, ), freezing_temperatures_calculated,                                                            method='linear', bounds_error=False, fill_value=None)        # Interpolate the missing values        P_MPa_extrapolate = P_MPa[np.isnan(P_MPa)]        freezing_temperatures_extrapolate = fn_frezchem_phaseRGI(P_MPa_extrapolate)        freezing_temperatures[np.isnan(freezing_temperatures)] = freezing_temperatures_extrapolate        # Return freezing temperatures        return freezing_temperatures    def PropsConstraintFinder(self, aqueous_species_string, speciation_ratio_per_kg):        """ Finds the constraints of pressure and temperature that are compatible with both phreeqc and supcrt databases for the given solution speciation.            ~ The lower temperature limit will be dynamically set by supcrt as equilibrium for this database can only be found starting at temperature of ~240K.            ~ The upper temperature is statically set to 400K            ~ The lower pressure limit will by statistically set to 0.1 MPa            ~ The upper pressure limit will be set to 200 MPa, the maximum pressure before high pressure ices            Returns adjusted pressure and temperature ranges with the found constraints. This approach is similar to MgSO4 solution, however we take advantage            of RKt's dynamic ability to find chemical equilibrium different depending on the solution, rather than hard coding in constraints.        Args:            P_MPa (shape N): Array of pressures that will be queried over in future functions, but needs to be checked to ensure the pressures are within ranges compatible with Rkt.            T_K (shape M): Array of temperatures that will be queried over in future functions, but needs to be checked to ensure the temperatures are within ranges compatible with Rkt.            aqueous_species_list: String that has all species names that should be considered in aqueous phase            speciation_ratio_per_kg: Dictionary of active species and the values of their molar ratio (mol/kg of water)        Returns:            P_MPa (AT MOST shape N): Adjusted array that only has values from initial P_MPa that are compatible with RKt.            P (AT MOST shape M): Adjusted array that only has values from initial T_K that are compatible with RKt.        """        # Dynamically find lower Tmin_K that supcrt can converge at        temperatureChange = lambda T: 0.5 - temperature_constraint(T, aqueous_species_string, speciation_ratio_per_kg,                                                                   "supcrt16")        if temperatureChange(Constants.SupcrtTmin_K) < 0:            log.debug(f"Will set lower EOS temperature boundary to {Constants.SupcrtTmin_K} K.")            Tmin_K = Constants.SupcrtTmin_K        else:            try:                Tmin_K = GetZero(temperatureChange, bracket=[Constants.SupcrtTmin_K, Constants.T0]).root            except:                log.warning(                    f"Supcrt could not converge at equilibrium for minimum EOS temperatures of {Constants.SupcrtTmin_K} to {273} K."                    f"We will still attempt to generate EOS for aqueous composition, but note that extrapolation will be occurring."                    f"Try to simplify aqueous composition so convergence is possible at these lower temperatures.")                Tmin_K = Constants.T0        Tmax_K = Constants.SupcrtTmax_K        Pmin_MPa = Constants.RktPmin_MPa        # Dynamically find upper Tmax_K that supcrt can converge at        pressureChange = lambda P: 0.5 - pressure_constraint(P, aqueous_species_string, speciation_ratio_per_kg,                                                             "supcrt16")        if pressureChange(Constants.SupcrtPmax_MPa) < 0:            log.debug(f"Will set upper EOS pressure boundary to {Constants.SupcrtPmax_MPa} MPa.")            Pmax_MPa = Constants.SupcrtPmax_MPa        else:            try:                Pmax_MPa = GetZero(pressureChange, bracket=[Constants.PminHPices_MPa, Constants.SupcrtPmax_MPa]).root            except:                log.warning(                    f"Supcrt could not converge at equilibrium for maxiumum pressures of {Constants.PminHPices_MPa} to {Constants.SupcrtPmax_MPa} MPa."                    f"We will still attempt to generate EOS for aqueous composition, but note that extrapolation will be occurring."                    f"Try to simplify aqueous composition so convergence is possible at these higher pressures.")                Pmax_MPa = Constants.PminHPices_MPa        return Tmin_K, Tmax_K, Pmin_MPa, Pmax_MPa    def RktProps(self, aqueous_species_list, speciation_ratio_mol_kg, P_MPa, T_K,                 database="supcrt16"):        """ Determine density rho, heat capacity Cp, thermal expansivity alpha,            and thermal conductivity kTherm as functions of pressure P and            temperature T for the provided solution species list and corresponding molarity ratios.            Implements Reaktoro Supcrt database to find these thermal properties at equilibrium for the prescribed pressure and temperature.            Importantly, if any thermal properties cannot be found due to equilibrium divergence, we perform a linear interpolation on these values, however            this outcome is HIGHLY UNLIKELY since we have found constraints that are compatible with Rkt, and user is warned if this does occur.        Args:            aqueous_species_string: String that has all species names that should be considered in aqueous phase            speciation_ratio_mol_kg: Dictionary of active species and the values of their molar ratio (mol/kg of water)            P_MPa (float, shape N): Pressures in MPa            T_K (float, shape M): Temperature in K            Returns:                rho_kgm3 (float, shape NxM): Mass density of liquid in kg/m^3                Cp_JkgK (float, shape NxM): Isobaric heat capacity of liquid in J/(kg K)                alpha_pK (float, shape NxM): Thermal expansivity of liquid in 1/K                kTherm_WmK (float, shape NxM): Thermal conductivity of liquid in W/(m K)        """        # Convert H2O label to H2O(aq) label for compatability with Supcrt database        aqueous_species_list, speciation_ratio_mol_kg = species_convertor_compatible_with_supcrt(aqueous_species_list,                                                                                                 speciation_ratio_mol_kg,                                                                                                 Constants.PhreeqcToSupcrtNames)        # Create lists of thermodynamic properties that will be of length NxM        rho_kgm3 = []        Cp_JKgK = []        alpha_pK = []        Vp_kms = []        mu_J_mol = []        # Disable chemical convergence warnings that Reaktoro raises. We handle these internally instead and throw more specific warnings when they appear.        rkt.Warnings.disable(906)        # Create Reaktoro objects        db, system, state, conditions, solver, props = SupcrtGenerator(aqueous_species_list, speciation_ratio_mol_kg,                                                                       ReaktoroParams.SPECIES_CONCENTRATION_UNIT,                                                                       database, ReaktoroParams.SOLID_PHASES, ReaktoroParams.SOLID_PHASES_TO_CONSIDER)        # Debug what solid phases are being considered relevant        if ReaktoroParams.SOLID_PHASES:            SolidPhases = system.species().withAggregateState(rkt.AggregateState.Solid)            relevant_phases = ''            for phase in SolidPhases:                relevant_phases += f' {phase.name()}'            log.debug(f'Considering the following solid phases when calculating thermodynamic properties: {relevant_phases}')        # Go through each pressure, temperature combination        for P in P_MPa:            # Establish equilibrium pressure constraint value            conditions.pressure(P, "MPa")            for T in T_K:                conditions.temperature(T, "K")                # Solve the equilibrium problem                result = solver.solve(state, conditions)                # Update the properties                props.update(state)                # Check if the equilibrium problem failed from this warm start approach                if not result.succeeded():                    # Cold restart the state and try again                    state = reset_state(system, speciation_ratio_mol_kg, ReaktoroParams.SPECIES_CONCENTRATION_UNIT)                    result = solver.solve(state, conditions)                if result.succeeded():                    # If it did succeed, obtain the relevant aqueous only phase props                    aqueous_props = props.phaseProps("AqueousPhase")                    # Obtain the thermodynamic properties of the aqueous phase                    rho_kg_m3 = aqueous_props.density()                    Cp_J_kg_K = aqueous_props.specificHeatCapacityConstP()                    # Obtain chemical potential of H2O(aq) and correct with correction spline                    aqueous_mu_J_mol = props.speciesChemicalPotential("H2O(aq)")                    aqueous_mu_J_mol = float(aqueous_mu_J_mol)                    # To calculate thermal coefficient, we will multiply inverse of specific volume by its                    # partial derivative with respect to temperature                    specific_volume_m3_kg = aqueous_props.specificVolume()                    dSpecificVolumedT = aqueous_props.specificVolumeT()                    thermalExpansivity_1_K = 1 / float(specific_volume_m3_kg) * float(dSpecificVolumedT)                    # To calculate sound speed, obtain specific volume and pressure derivative of specific volume                    specific_volume_m3_kg = float(aqueous_props.specificVolume())                    pressure_derivative_specific_volume = float(aqueous_props.specificVolumeP())                    # Calculate commpressibility factor, multiplying negative inverse of specific volume by pressure derivative of specific volume                    k_compressibility = -(1 / specific_volume_m3_kg) * pressure_derivative_specific_volume                    # Calculate sound speed, multiplying k by density and taking the product to the -0.5                    c_m_s = (rho_kg_m3 * k_compressibility) ** (-0.5)                    # Convert to km/s                    c_km_s = c_m_s / 1000                    # Append the values to the associated array                    rho_kgm3.append(float(rho_kg_m3))                    Cp_JKgK.append(float(Cp_J_kg_K))                    alpha_pK.append(float(thermalExpansivity_1_K))                    Vp_kms.append(float(c_km_s))                    mu_J_mol.append(float(aqueous_mu_J_mol))                # Otherwise, the equilibrium problem failed so we need to handle it accordingly                # THIS IS VERY UNLIKELY SINCE WE HAVE ESTABLISHED CONSTRAINTS OF TEMPERATURE AND PRESSURE THAT SHOULD WORK WITH SUPCRT                else:                    # Log to the user that the computation was unsuccessful and that missed value will be extrapolated                    log.debug(                        f"Unsuccessful computation at: {props.pressure() / 1e+6} MPa and {props.temperature()} K.\n"                        f"The temperature and pressure may be out of bounds, thus we will linearly extrapolate this value from previous ones using a 2d interopolation")                    # Reset the state                    state = reset_state(system, speciation_ratio_mol_kg, ReaktoroParams.SPECIES_CONCENTRATION_UNIT)                    # Append zeros, which will be modified later                    rho_kgm3.append(np.nan)                    Cp_JKgK.append(np.nan)                    alpha_pK.append(np.nan)                    Vp_kms.append(np.nan)                    mu_J_mol.append(np.nan)            # After going through each entire temperature range for given pressure, reset state            state = reset_state(system, speciation_ratio_mol_kg, ReaktoroParams.SPECIES_CONCENTRATION_UNIT)        # Turn the list into an array of shape NxM        rho_kgm3 = np.array(rho_kgm3).reshape((P_MPa.size, -1))        Cp_JKgK = np.array(Cp_JKgK).reshape((P_MPa.size, -1))        alpha_pK = np.array(alpha_pK).reshape((P_MPa.size, -1))        Vp_kms = np.array(Vp_kms).reshape((P_MPa.size, -1))        mu_J_mol = np.array(mu_J_mol).reshape((P_MPa.size, -1))        # In the case that any properties could not be calculated, we must linearly interpolate these        # THIS IS HIGHLY UNLIKELY SINCE WE HAVE FOUND CONSTRAINTS COMPATIBLE WITH RKT, BUT JUST IN CASE THIS IS IMPLEMENTED (has not been rigorously tested)        if np.sum(np.isnan(rho_kgm3)) > 0:            rho_kgm3, Cp_JKgK, alpha_pK, Vp_kms, mu_J_mol = interpolation_2d(P_MPa,                                                                             [rho_kgm3, Cp_JKgK, alpha_pK, Vp_kms,                                                                              mu_J_mol])        # Return the thermodynamic properties        return rho_kgm3, Cp_JKgK, alpha_pK, Vp_kms, mu_J_molclass RktPhaseLookup:    def __init__(self, EOS_lookup_label, aqueous_species_string, speciation_ratio_per_kg, P_MPa, T_K):        self.fLookup = os.path.join(ReaktoroParams.rktPath, 'CustomSolutionLookupTables',                                    f'phase_{EOS_lookup_label}.mat')        if self.fLookup in EOSlist.loaded.keys():            log.debug(f'EOS phase lookup table with label {EOS_lookup_label} already loaded.')            self.fn_frezchem_phaseRGI, self.fn_mu_J_mol = EOSlist.loaded[self.fLookup]            self.Pmin, self.Pmax, self.deltaP, self.deltaT = EOSlist.ranges[self.fLookup]        else:            EOSLookupTables = EOSLookupTableLoader(aqueous_species_string, speciation_ratio_per_kg, EOS_lookup_label)            log.debug(f'Loading EOS phase lookup table at {self.fLookup}.')            fRktPhase = EOSLookupTables.phase_EOS            PRkt_MPa = fRktPhase['P_MPa']            self.Pmin = np.min(PRkt_MPa)            self.deltaP = np.maximum(np.round(np.mean(np.diff(PRkt_MPa)), 2), 0.001)            self.fn_frezchem_phaseRGI = RegularGridInterpolator((PRkt_MPa,), fRktPhase['TFreezing_K'],                                                       method='linear', bounds_error=False, fill_value=None)            # Gets the RktPropsLookup again. This should be quick as we have already loaded it into EOSlist using RktProps called before            fn_RktProps = RktPropsLookup(EOS_lookup_label, aqueous_species_string, speciation_ratio_per_kg)            # Get the temperature limits            self.Pmax = fn_RktProps.Pmax            self.Tmin = fn_RktProps.Tmin            self.Tmax = fn_RktProps.Tmax            self.deltaT = fn_RktProps.EOSdeltaT            # Reassign the functions so they can be referenced when object is called            self.fn_mu_J_mol = fn_RktProps.fn_mu_J_mol            # Save functions to EOSlist so they can be referenced in future            self.deltaT = ReaktoroParams.EOS_deltaT            EOSlist.loaded[self.fLookup] = self.fn_frezchem_phaseRGI, self.fn_mu_J_mol            EOSlist.ranges[self.fLookup] = (self.Pmin, self.Pmax, self.deltaP, self.deltaT)        # Generate pressure and temperature arrays hat extend to limits of EOS pressure and temperature but        # use the fidelity of the temperature and pressure steps of EOS (i.e. deltaT and deltaP)        self.deltaP = np.min([self.deltaP, P_MPa[1]-P_MPa[0]])        self.deltaT = np.min([self.deltaT, T_K[1]-T_K[0]])        P_MPa_to_query = np.arange(P_MPa[0], P_MPa[-1], self.deltaP)        T_K_to_query = np.arange(T_K[0], T_K[-1], self.deltaT)        self.phase_lookup_grid = self.phase_lookup_grid_generator(P_MPa_to_query, T_K_to_query, self.fn_frezchem_phaseRGI, self.fn_mu_J_mol)        self.fn_phase = RegularGridInterpolator((P_MPa_to_query, T_K_to_query), self.phase_lookup_grid, method='nearest', bounds_error=False, fill_value=None)    def __call__(self, P_MPa, T_K,  grid=False):        if grid:            P_MPa, T_K = np.meshgrid(P_MPa, T_K, indexing='ij')        return (self.fn_phase((P_MPa, T_K)))    def phase_lookup_grid_generator(self, P_MPa, T_K, freezing_temperature_function_below_200_MPa, mu_function_above_200_MPa):        P_MPa_below_200_MPa_index = np.searchsorted(P_MPa, 200, side = 'left')        phases = []        if P_MPa_below_200_MPa_index > 0:            P_MPa_below_200_MPa = P_MPa[0:P_MPa_below_200_MPa_index]            freezing_temperatures = freezing_temperature_function_below_200_MPa(P_MPa_below_200_MPa)            freezing_temperatures, T_K_pts = np.meshgrid(freezing_temperatures, T_K, indexing='ij')            phases = phases + (T_K_pts < freezing_temperatures).astype(np.int_).tolist()        if P_MPa_below_200_MPa_index < P_MPa.size:            P_MPa_above_200_MPa = P_MPa[P_MPa_below_200_MPa_index:]            evalPts_RGI = tuple(np.meshgrid(P_MPa_above_200_MPa, T_K))            evalPts_sfz = np.array([P_MPa_above_200_MPa, T_K], dtype=object)            ptsh = (P_MPa_above_200_MPa.size, T_K.size)            max_phase_num = max([p for p in Constants.seafreeze_ice_phases.keys()])            comp = np.full(ptsh + (max_phase_num + 1,), np.nan)            for phase, name in Constants.seafreeze_ice_phases.items():                if phase == 0:                    mu_J_mol = mu_function_above_200_MPa(evalPts_RGI).T                else:                    mu_J_mol = sfz.getProp(evalPts_sfz, name).G * Constants.m_gmol['H2O'] / 1000                sl = tuple(repeat(slice(None), 2)) + (phase,)                comp[sl] = np.squeeze(mu_J_mol)            all_nan_sl = np.all(np.isnan(comp), -1)  # Find slices where all values are nan along the innermost axis            out_phase = np.full(ptsh, np.nan)            out_phase[~all_nan_sl] = np.nanargmin(comp[~all_nan_sl], -1)            phases = phases + out_phase.tolist()        phases = np.array(phases).reshape(P_MPa.size, T_K.size)        return phasesdef ensureArray(var):    if isinstance(var, Iterable):        return var    else:        return np.array([var])def SpeciesParser(species_string_with_ratios):    '''    Converts the provided String of species and their molar ratios into formats necessary for Reaktoro. Namely, creates    a String of all the species in the list and a dictionary with 'active' species that are added to solution (the observer species are    automatically generated to be 1e-16 moles in the solution by Reaktoro). It also returns the w_ppt of the solution. If any of the species do not exist in the database Reaktoro is implementing    (namely the frezchem database), this method raises an error that the species does not exist.     Parameters     ----------     species_string_with_ratios: String of all the species that should be considered in aqueous phase and their corresponding molar ratios.        For example, "Cl-: 19.076, Na+: 5.002, Ca2+: 0.0"     Returns     -------     aqueous_species_string: String that has all species names that should be considered in aqueous phase     speciation_ratio_per_kg: Dictionary of active species and the values of their molar ratio (g/kg or mol/kg of water)     EOS_lookup_label: EOS table lookup label    '''    species_string_with_ratios =  species_string_with_ratios.split('=')[1].strip()    # Initialize the Phreeqc database with frezchem    frezchem_db = rkt.PhreeqcDatabase.fromFile(ReaktoroParams.frezchemPath)    # Create a new string that will hold all the aqueous species in a format compatible with Reaktoro    aqueous_species_string = ""    # Create a new string that will be the EOS lookup table label, starting with customLabel    EOS_lookup_label = ""    # Create a new dictionary that will hold all the aqueous species with a specified amount to add in a format compatible with Reaktoro    speciation_ratio_per_kg = {}    # Go through each species and corresponding ratio_per_kg and add to corresponding lists    for species_with_ratio in species_string_with_ratios.split(", "):        species, ratio_per_kg = species_with_ratio.split(": ")        # Ensure that species is in frezchem database and if not then raise error        try:            frezchem_db.species(species)        except:            raise ValueError(                f'{species} does not exist in the Phreeqc database. Check that it is entered correctly in the Planet.ocean.species')        # Add species to string        aqueous_species_string = aqueous_species_string + species + " "        # Check if the species is active (amount > 0 mol) and if so, add it to the dictionary        if (float(ratio_per_kg) > 0):            speciation_ratio_per_kg[species] = float(ratio_per_kg)        # Add species and concentration to customLabel        EOS_lookup_label = EOS_lookup_label + f'_{species}-{ratio_per_kg}'    # Add H+ and OH- to species string so we can track pH    if not "H+" in aqueous_species_string:        aqueous_species_string = aqueous_species_string + "H+ "    if not "OH-" in aqueous_species_string:        aqueous_species_string = aqueous_species_string + "OH- "    # Check if water is in the aqueous species string and dictionary and if not, add it, ensuring to update the weight to be 1kg    if not "H2O" in aqueous_species_string:        aqueous_species_string = aqueous_species_string + "H2O "    # Ensure H2O amount is a mol or g equivalent of 1kg    if "mol" in ReaktoroParams.SPECIES_CONCENTRATION_UNIT:        speciation_ratio_per_kg.update({"H2O": float(1 / rkt.waterMolarMass)})    elif "g" in ReaktoroParams.SPECIES_CONCENTRATION_UNIT:        speciation_ratio_per_kg.update({"H2O": 1000.0})    # Get keyword mineral phases if needed and update    if ReaktoroParams.SOLID_PHASES:        solid_phases = []        for solid_phase in ReaktoroParams.SOLID_PHASES_TO_CONSIDER:            if solid_phase in Constants.SolidPhases:                solid_phases = solid_phases + Constants.SolidPhases[solid_phase]            else:                solid_phases.append(solid_phase)        # Update solid_phases        ReaktoroParams.SOLID_PHASES_TO_CONSIDER = solid_phases    # Append if phases should be considered for EOS    EOS_lookup_label = EOS_lookup_label + f'_Consider_Solids_{ReaktoroParams.SOLID_PHASES}'    # Return the species string and dictionary (remove the trailing white space from the String as well with rstrip())    return aqueous_species_string.rstrip(" "), speciation_ratio_per_kg, EOS_lookup_label.strip('_')class RktConduct():    def __init__(self, aqueous_species_list, speciation_ratio_mol_kg):        """        Initialize the RKtConduct() object and parse the aqueous species list into a format compatible with elecCondMcClevskey2012()        """        self.ions = McClevskyIonParser(speciation_ratio_mol_kg, ReaktoroParams.SPECIES_CONCENTRATION_UNIT)    def __call__(self, P_MPa, T_K, grid=False):        """        Finds electrical conductivity for given ions. Currently does not adjust for pressure.        Args:            Array of pressures            T_K (float, Shape N): Array of temperatures            grid: Whether or not they need to be made into a coordinate grid        Returns:            VP_kms (float, Shape N): Corresponding sound speeds in km/s            KS_GPa (float, Shape N): Corresponding bulk modulus in GPa        """        if grid:            P_MPa, T_K = np.meshgrid(P_MPa, T_K, indexing='ij')        else:            P_MPa = np.array(P_MPa)            T_K = np.array(T_K)            if (np.size(P_MPa) == 0 or np.size(T_K) == 0):                # If input is empty, return empty array                return np.array([])            elif ((np.size(P_MPa) != np.size(T_K)) and not (np.size(P_MPa) == 1 or np.size(T_K) == 1)):                # If arrays are different lengths, they are probably meant to get a 2D output                P_MPa, T_K = np.meshgrid(P_MPa, T_K, indexing='ij')        T_C = T_K - Constants.T0        sigma_Sm = elecCondMcCleskey2012(P_MPa, T_C, self.ions)        return sigma_Smclass Reaktoro_Hydro_Species_Generator():    def __init__(self, aqueous_species_list, speciation_ratio_mol_kg):        # Convert H2O label to H2O(aq) label for compatability with Supcrt database        self.aqueous_species_list, self.speciation_ratio_mol_kg = species_convertor_compatible_with_supcrt(            aqueous_species_list, speciation_ratio_mol_kg, Constants.PhreeqcToSupcrtNames)    def __call__(self, P_MPa, T_K, grid=False):        """ Calculates speciation of composition at provided pressure and temperature using Supcrt. Notably,        we have to reset the pressure since we cannot calculate equilibrium above 500MPa using Supcrt."""        # Reset P_MPa so that it does not extend above 500MPa, since supcrt cannot go above this pressure        newP_MPa, newT_K = ResetNearestExtrap(P_MPa, T_K, P_MPa[0], Constants.SupcrtPmax_MPa, T_K[0], T_K[-1])        if (not np.all(newP_MPa == P_MPa)) or (not np.all(newT_K == T_K)):            log.warning(                'Supcrt can only accurate calculate hydrosphere species up to 500MPa, so we will reset hydro species function call up to the ocean depth that correlates with 500MPa.' +                f'{newP_MPa[0]}, {newP_MPa[-1]} MPa and [Tmin, Tmax] = ' +                f'{newT_K[0]}, {newT_K[-1]} K. Will reset the inputs to stay within the ranges.')            P_MPa = newP_MPa            T_K = newT_K        if grid:            P_MPa, T_K = np.meshgrid(P_MPa, T_K, indexing='ij')        else:            P_MPa = np.array(P_MPa)            T_K = np.array(T_K)            if (np.size(P_MPa) == 0 or np.size(T_K) == 0):                # If input is empty, return empty array                return np.array([])            elif ((np.size(P_MPa) != np.size(T_K)) and not (np.size(P_MPa) == 1 or np.size(T_K) == 1)):                # If arrays are different lengths, they are probably meant to get a 2D output                P_MPa, T_K = np.meshgrid(P_MPa, T_K, indexing='ij')        return self.species_at_equilibrium(P_MPa, T_K, self.speciation_ratio_mol_kg)    def species_at_equilibrium(self, P_MPa, T_K, speciation_ratio_per_kg):        """        Go through P_MPa and T_K  and calculate equilibrium speciation of aqueous and solid species, as well as pH.        Return species above        """        # Keep track of time it takes to do calculation        start_time = time.time()        # Establish supcrt generator        db, system, state, conditions, solver, props = SupcrtGenerator(self.aqueous_species_list, self.speciation_ratio_mol_kg,                                      ReaktoroParams.SPECIES_CONCENTRATION_UNIT, "supcrt16", ReaktoroParams.SOLID_PHASES, ReaktoroParams.SOLID_PHASES_TO_CONSIDER)        # Prepare lists for pH and species amounts        pH_list = []        species_list = [[] for _ in range(len(system.species()))]        species_names = np.array([species.name() for species in system.species()])  # Extract species names        for P, T in zip(P_MPa, T_K):            conditions.temperature(T, "K")            conditions.pressure(P, "MPa")            # Solve the equilibrium problem using the hot-start approach            result = solver.solve(state, conditions)            if not result.succeeded():                # Attempt a cold start                state = reset_state(system, speciation_ratio_per_kg, ReaktoroParams.SPECIES_CONCENTRATION_UNIT)                result = solver.solve(state, conditions)            if result.succeeded():                # Update props and extract data                props.update(state)                aprops = rkt.AqueousProps(props)                pH_list.append(float(aprops.pH()))                for k, species in enumerate(system.species()):                    species_list[k].append(float(state.speciesAmount(species.name())))            else:                log.warning(f"Failed to find equilibrium at {P} MPa and {T} K. Filling with NaN.")                pH_list.append(np.nan)                for k in range(len(system.species())):                    species_list[k].append(np.nan)                state = reset_state(system, speciation_ratio_per_kg, ReaktoroParams.SPECIES_CONCENTRATION_UNIT)        # Convert lists to arrays        pH_array = np.array(pH_list)        species_array = np.array(species_list).T  # Transpose to get shape of (#(P_MPa), num_species)        # Log time it took to calculate speciation        end_time = time.time()        log.debug(f'{end_time-start_time} seconds to calculate hydrosphere species')        # Return the filtered results        return pH_array, species_array, species_namesdef temperature_constraint(T_K, aqueous_species_list, speciation_ratio_mol_kg, database):    """ Find the pressure constraint at which Reaktoro can find equilibrium for the given speciation and database. Checks if rkt can find equilibrium        with a pressure of 0.1 MPa at T_K temperature. If it cannot, then returns 0. If it can, then returns 1.    Args:        T_K: Initial temperature constraint in K        aqueous_species_list: String that has all species names that should be considered in aqueous phase        speciation_ratio_mol_kg: Dictionary of active species and the values of their molar ratio (mol/kg of water)        database: Database to find temperature constraint for        dT: The amount to change T_K by if equilibrium is not achieved. Defaults to 1 (for lower constraint)    Returns:        1 if equilibrium found        0 if equilibrium not found    """    # Initilialize the database, either being supcrt of phreeqc    if "supcrt" in database:        # Since supcrt labels "H2O(aq)", we need to adjust our species list and dictionary accordingly        aqueous_species_list, speciation_ratio_mol_kg = species_convertor_compatible_with_supcrt(            aqueous_species_list, speciation_ratio_mol_kg, Constants.PhreeqcToSupcrtNames)        db, system, state, conditions, solver, props = SupcrtGenerator(aqueous_species_list, speciation_ratio_mol_kg,                                                                       ReaktoroParams.SPECIES_CONCENTRATION_UNIT,                                                                       database, ReaktoroParams.SOLID_PHASES, ReaktoroParams.SOLID_PHASES_TO_CONSIDER)    else:        db, system, state, conditions, solver, props, ice_name, database_name = PhreeqcGenerator(aqueous_species_list,                                                                                                 speciation_ratio_mol_kg,                                                                                                 ReaktoroParams.SPECIES_CONCENTRATION_UNIT,                                                                                                 database)    # Establish pressure constraint of 1bar    conditions.pressure(1, "MPa")    conditions.temperature(T_K, "K")    # Solve the equilibrium problem    result = solver.solve(state, conditions)    # Check if the equilibrium problem succeeded    if result.succeeded():        return 1    else:        return 0def pressure_constraint(P_MPa, aqueous_species_list, speciation_ratio_mol_kg, database):    """ Find the pressure constraint at which Reaktoro can find equilibrium for the given speciation and database. Checks if rkt can find equilibrium at 273K at P_MPa pressure.    If it cannot, then returns 0. If it can, then returns 1.    Args:        P_MPa: Pressure to find equilibrium: P_MPa        aqueous_species_list: String that has all species names that should be considered in aqueous phase        speciation_ratio_mol_kg: Dictionary of active species and the values of their molar ratio (mol/kg of water)        database: Database to find temperature constraint for        dT: The amount to change T_K by if equilibrium is not achieved. Defaults to 1 (for lower constraint)    Returns:        1 if equilibrium found        0 if equilibrium not found    """    # Disable chemical convergence warnings that Reaktoro raises. We handle these internally instead and throw more specific warnings when they appear.    rkt.Warnings.disable(906)    # Initilialize the database, either being supcrt of phreeqc    if "supcrt" in database:        # Since supcrt labels "H2O(aq)", we need to adjust our species list and dictionary accordingly        aqueous_species_list, speciation_ratio_mol_kg = species_convertor_compatible_with_supcrt(            aqueous_species_list, speciation_ratio_mol_kg, Constants.PhreeqcToSupcrtNames)        db, system, state, conditions, solver, props = SupcrtGenerator(aqueous_species_list, speciation_ratio_mol_kg,                                                                       ReaktoroParams.SPECIES_CONCENTRATION_UNIT,                                                                       database, ReaktoroParams.SOLID_PHASES, ReaktoroParams.SOLID_PHASES_TO_CONSIDER)        # Establish pressure constraint of 1bar        conditions.pressure(P_MPa, "MPa")        conditions.temperature(Constants.T0, "K")        # Solve the equilibrium problem        result = solver.solve(state, conditions)        # Check if the equilibrium problem succeeded        if result.succeeded():            return 1        else:            return 0    else:        db, system, state, conditions, solver, props, ice_name, database_name = PhreeqcGeneratorForChemicalConstraint(aqueous_species_list,                                                                                                 speciation_ratio_mol_kg,                                                                                                 ReaktoroParams.SPECIES_CONCENTRATION_UNIT,                                                                                                 database)        conditions.pressure(P_MPa, "MPa")        conditions.set("IP", 0.1)        conditions.setLowerBoundTemperature(230, "K")        conditions.setUpperBoundTemperature(300, "K")        # Solve the equilibrium problem        result = solver.solve(state, conditions)        if result.succeeded():            return 1        else:            return 0class RktSeismicOnDemand():    def __init__(self, aqueous_species_list, speciation_ratio_mol_kg, TMin_K, TMax_K, PMin_MPa, PMax_MPa):        """        Initialize the RKtSeismic() object with the minimum and maximum T (in K) and P (in MPa) and speciation info.        """        self.aqueous_species_list = aqueous_species_list        self.speciation_ratio_mol_kg = speciation_ratio_mol_kg        self.TMin_K = TMin_K        self.TMax_K = TMax_K        self.PMin_MPa = PMin_MPa        self.PMax_MPa = PMax_MPa    def __call__(self, P_MPa, T_K, grid=False):        """        Finds the sound speed in km/s and bulk modulus in GPa for the input of P_MPa and T_K        Args:            P_MPa (float, Shape N): Array of pressures            T_K (float, Shape N): Array of temperatures            grid: Whether or not they need to be made into a coordinate grid        Returns:            VP_kms (float, Shape N): Corresponding sound speeds in km/s            KS_GPa (float, Shape N): Corresponding bulk modulus in GPa        """        if grid:            P_MPa, T_K = np.meshgrid(P_MPa, T_K, indexing='ij')        else:            P_MPa = np.array(P_MPa)            T_K = np.array(T_K)            if (np.size(P_MPa) == 0 or np.size(T_K) == 0):                # If input is empty, return empty array                return np.array([])            elif ((np.size(P_MPa) != np.size(T_K)) and not (np.size(P_MPa) == 1 or np.size(T_K) == 1)):                # If arrays are different lengths, they are probably meant to get a 2D output                P_MPa, T_K = np.meshgrid(P_MPa, T_K, indexing='ij')        # Finds the sound speed and associated densities for the given pressure and temperature inputs        VP_kms, rho_kgm3 = self.seismic_calculations(self.aqueous_species_list, self.speciation_ratio_mol_kg, P_MPa,                                                     T_K)        # Calculates the bulk modulus from its relaiontship with sound speed and density        KS_GPa = rho_kgm3 * VP_kms ** 2 * 1e-3  # 1e-3 because (km/s)^2 * (kg/m^3) gives units of MPa, so 1e-3 to convert to GPa        # Return sound speed and bulk modulus        return VP_kms, KS_GPa    def seismic_calculations(self, aqueous_species_list, speciation_ratio_mol_kg, P_MPa, T_K, database="supcrt16"):        """        Calculates the sound speed and densities of the aqueous phase of the solution for the input pressure and temperatures,        utilizing the thermodynamic properties provided by the supcrt database at equilibrium.        Args:            aqueous_species_list: aqueous species in reaction. Should be formatted in one long string with a space in between each species            speciation_ratio_mol_kg: the ratio of species in the aqueous solution in mol/kg of water. Should be a dictionary with the species as the key and its ratio as its value.            P_MPa (float, shape N): the desired equilibrium freezing pressure(s) in an array of size N.            T_K (float, shape N): the desired equilibrium freezing temperature(s) in an array of size N.        Returns:            sound_speeds (float, shape N): Associated aqueous sound speeds in km/s            densities (float, shape N): Associated aqueous densities in km/s        """        # Convert H2O label to H2O(aq) label for compatability with Supcrt database        aqueous_species_list, speciation_ratio_mol_kg = species_convertor_compatible_with_supcrt(            aqueous_species_list, speciation_ratio_mol_kg, Constants.PhreeqcToSupcrtNames)        # Disable chemical convergence warnings that Reaktoro raises. We handle these internally instead and throw more specific warnings when they appear.        rkt.Warnings.disable(906)        # Create list that will become array that will hold sound speeds        sound_speeds = []        # Create list that will become array taht holds corresponding aqueous densities        densities = []        # Create Reaktoro objects        db, system, state, conditions, solver, props = SupcrtGenerator(aqueous_species_list,                                                                       speciation_ratio_mol_kg,                                                                       ReaktoroParams.SPECIES_CONCENTRATION_UNIT,                                                                       database, ReaktoroParams.SOLID_PHASES, ReaktoroParams.SOLID_PHASES_TO_CONSIDER)        # Create an iterator to go through P_MPa and T_K        it = np.nditer([P_MPa, T_K], flags=['multi_index'])        # Go through each (P,T) combination, where we assume that P_MPa and T_K are same size and correspond to one another        for P, T in it:            P = float(P)            T = float(T)            conditions.temperature(T, "K")            conditions.pressure(P, "MPa")            # Solve the equilibrium problem            result = solver.solve(state, conditions)            # Update the properties            props.update(state)            # Check if the equilibrium problem succeeded            if result.succeeded():                # If it did succeed, obtain the relevant aqueous only phase props                aqueous_props = props.phaseProps("AqueousPhase")                # Obtain density, specific volume, and pressure derivative of specific volume                density_kg_m3 = float(aqueous_props.density())                specific_volume_m3_kg = float(aqueous_props.specificVolume())                pressure_derivative_specific_volume = float(aqueous_props.specificVolumeP())                # Calculate commpressibility factor, multiplying negative inverse of specific volume by pressure derivative of specific volume                k_compressibility = -(1 / specific_volume_m3_kg) * pressure_derivative_specific_volume                # Calculate sound speed, multiplying k by density and taking the product to the -0.5                c_m_s = (density_kg_m3 * k_compressibility) ** (-0.5)                # Convert to km/s                c_km_s = c_m_s / 1000                # Append to lists                sound_speeds.append(c_km_s)                densities.append(density_kg_m3)                # Reset the state                state = reset_state(system, speciation_ratio_mol_kg, ReaktoroParams.SPECIES_CONCENTRATION_UNIT)            # If equilibrium did not succeed, then we will linearly interpolate these values            # THIS IS VERY UNLIKELY SINCE WE ARE CALCULATING SEISMIC VALUES FOR OCEAN LAYER WHICH HAS ALREADY BEEN CALCULATED BY RKT, SO VALUES SHOULD BE WITHIN RANGE OF RKT            else:                # For now, just append np.nan and we will handle later                sound_speeds.append(np.nan)                densities.append(np.nan)                # Reset the state                state = reset_state(system, speciation_ratio_mol_kg, ReaktoroParams.SPECIES_CONCENTRATION_UNIT)        # Convert lists to arrays        sound_speeds = np.array(sound_speeds).reshape(P_MPa.shape)        densities = np.array(densities).reshape(P_MPa.shape)        # Check if any values are np.nan, which indicates they were not found in chemical equilibrium        # THIS IS VERY UNLIKELY SINCE RKT SHOULD BE ABLE TO HANDLE INPUT P AND T RANGE, HOWEVER FOR SELF-CONSISTENCY WE ADD THIS IN CASE        if np.sum(np.isnan(sound_speeds)) > 0:            sound_speeds, densities = interpolation_1d(P_MPa, [sound_speeds, densities])            log.warning("Performed 1d linear interpolation on missing seismic properties")        return sound_speeds, densitiesclass RktPhaseOnDemand:    """    Class that can find the phase of a given speciation over a range of temperatures and pressures    """    def __init__(self, aqueous_species_list, speciation_ratio_mol_kg):        """        Initialize the RKtPhaseOnDemand object that will find the phase (liquid or Ice 1) for a input pressure and        temperature using the Frezchem database. Uses a temperature correction function previously calculated in comparsion with Seafreeze.        """        self.aqueous_species_list = aqueous_species_list        self.speciation_ratio_mol_kg = speciation_ratio_mol_kg        # Create both frezchem and core Reaktoro systems that can be utilized later on        self.frezchem = PhreeqcGeneratorForChemicalConstraint(self.aqueous_species_list, self.speciation_ratio_mol_kg,                                                              ReaktoroParams.SPECIES_CONCENTRATION_UNIT,                                                              ReaktoroParams.frezchemPath)        # Obtain internal temperature correction spline        # self.temperature_correction_spline = FrezchemFreezingTemperatureCorrectionSplineGenerator()        self.spline_for_pressures_above_100_MPa, self.PMax_MPa = self.Frezchem_Spline_Generator(            self.aqueous_species_list, self.speciation_ratio_mol_kg, self.temperature_correction_spline)        self.calculated_freezing_temperatures = {}    def __call__(self, P_MPa, T_K, grid=False):        """        Call the ice_freezing function for the given input P_MPa and T_K coordinates.        Importantly, ice_frrezing assumes P_MPa and T_K are the same size and correspond to one another (coordinate pairs),        so we get them into that format if they are not already.        Args:            P_MPa: Array of pressures            T_K: Array of temperatures            grid: Whether or not they need to be made into a coordinate grid        Returns:            The associated phases of the solution for the input pressure and temperatures        """        if not grid:            np.array(P_MPa)            np.array(T_K)        freezing_temperatures = self.rkt_t_freeze(self.aqueous_species_list, self.speciation_ratio_mol_kg, P_MPa,                                                  self.frezchem, self.PMax_MPa, self.spline_for_pressures_above_100_MPa,                                                  self.calculated_freezing_temperatures,                                                  self.temperature_correction_spline)        if grid:            freezing_temperatures, T_K = np.meshgrid(freezing_temperatures, T_K, indexing='ij')        return (T_K < freezing_temperatures).astype(np.int_)    def Frezchem_Spline_Generator(self, aqueous_species_list, speciation_ratio_mol_kg, temperature_correction_spline,                                  data_points=30,                                  significant_threshold=0.1):        P_MPa = np.linspace(0.1, 100, data_points)        # Disable chemical convergence warnings that Reaktoro raises. We handle these internally instead and throw more specific warnings when they appear.        rkt.Warnings.disable(906)        TMin_K = 220        TMax_K = 300        # Create Reaktoro objects        db, system, state, conditions, solver, props = PhreeqcGeneratorForChemicalConstraint(aqueous_species_list,                                                                                             speciation_ratio_mol_kg,                                                                                             ReaktoroParams.SPECIES_CONCENTRATION_UNIT,                                                                                             ReaktoroParams.frezchemPath)        # Create freezing temperatures list and indices of pressures to remove, if necessary        freezing_temperatures = []        indices_to_remove = []        for index, P in enumerate(P_MPa):            # Specify equilibrium constraints            conditions.pressure(P, "MPa")            conditions.set("IP", significant_threshold)            conditions.setLowerBoundTemperature(TMin_K, "K")            conditions.setUpperBoundTemperature(TMax_K, "K")            # Solve the equilibrium problem            result = solver.solve(state, conditions)            # Update the properties            props.update(state)            # Obtain the equilibrium temperature            equilibrium_temperature = props.temperature()            # Correct equilibrium temperature with correction spline            corrected_temperature = float(equilibrium_temperature) + temperature_correction_spline(P)            # Check if the result succeeded            if result.succeeded():                freezing_temperatures.append(corrected_temperature)                state = reset_state(system, speciation_ratio_mol_kg, ReaktoroParams.SPECIES_CONCENTRATION_UNIT)            # If the result failed, then do not include this in list of freezing temperatures and remove from pressure list to avoid its use in creating spline            else:                indices_to_remove.append(index)                state = reset_state(system, speciation_ratio_mol_kg, ReaktoroParams.SPECIES_CONCENTRATION_UNIT)        # Remove pressures that failed to find equilibrium        if len(indices_to_remove) > 5:            log.warning(                "Reaktoro had a difficult time finding convergence of species composition to generate spline over range of [0.1, 100] MPa. Be warned that results are being extrapolated far beyond Frezchem's ability.")        P_MPa = np.delete(P_MPa, indices_to_remove)        # Convert freezing_temperatures to array        freezing_temperatures = np.array(freezing_temperatures)        # Create b-spline        spline = interpolate.make_interp_spline(P_MPa, freezing_temperatures, k=2)        # Find highest pressure at which Frezchem could find freezing temperature for given composition        max_pressure = P_MPa[-1]        # Return spline and max pressure        return spline, max_pressure    def rkt_t_freeze(self, aqueous_species_list, speciation_ratio_mol_kg, P_MPa, frezchem, PMax_MPa,                     freezing_temperature_spline, calculated_freezing_temperatures, temperature_correction_spline,                     TMin_K=220, TMax_K=300,                     significant_threshold=0.1):        """         Calculates the temperature at which the prescribed aqueous solution freezes. Utilizes the reaktoro framework to         constrain the equilibrium position at the prescribed pressure, the lower and upper limits of temperature (in K),         and the total amount of ice at a significant threshold of 1e-14, therefore calculating and returning the         temperature (within the range) at which ice begins to form.         Parameters         ----------         aqueous_species_list: aqueous species in reaction. Should be formatted in one long string with a space in between each species         speciation_ratio_mol_kg: the ratio of species in the aqueous solution in mol/kg of water. Should be a dictionary         with the species as the key and its ratio as its value.         P_MPa: the desired equilibrium freezing pressure(s).         TMin_K: the lower limit of temperature that Reaktoro should query over         TMax_K: the upper limit of temperature that Reaktoro should query over         significant_threshold: the amount of moles of ice present for H2O to be considered in solid phase. Default is 1e-14 moles.         Returns         -------         t_freezing_K: the temperature at which the solution begins to freeze.         """        # Disable chemical convergence warnings that Reaktoro raises. We handle these internally instead and throw more specific warnings when they appear.        # rkt.Warnings.disable(906)        # Create list that holds boolean values of whether ice is present        freezing_temperatures = []        db, system, state, conditions, solver, props = frezchem        state = rkt.ChemicalState(state)        # Create an iterator to go through P_MPa        it = np.nditer([P_MPa])        conditions.set("IP", significant_threshold)        conditions.setLowerBoundTemperature(TMin_K, "K")        conditions.setUpperBoundTemperature(TMax_K, "K")        for P in it:            P = float(P)            # Adjust Pressure            if P in calculated_freezing_temperatures.keys():                equilibrium_temperature = calculated_freezing_temperatures[P]                freezing_temperatures.append(equilibrium_temperature)                continue            # Check that pressure is below PMax_MPa, the maximum pressure constraint calculated previously            if P <= PMax_MPa:                # Specify equilibrium constraints                conditions.pressure(P, "MPa")                # Solve the equilibrium problem                result = solver.solve(state, conditions)                # Update the properties                props.update(state)                # Obtain the equilibrium temperature                equilibrium_temperature = props.temperature()                # Correct the equilibrium temperature using the temperature correction spline                equilibrium_temperature = equilibrium_temperature + temperature_correction_spline(P)                # Check if the result succeeded                if result.succeeded():                    state = reset_state(system, speciation_ratio_mol_kg, ReaktoroParams.SPECIES_CONCENTRATION_UNIT)                # If the result failed, we will use spline                else:                    log.warning(f"While attempting to find bottom freezing temperature for pressure of {P} MPa, \n"                                + f"Reaktoro was unable to find a temperature within range of {TMin_K} K and {TMax_K}.\n"                                + f"Instead, we will use a spline of freezing temperatures that we generated for this EOS to find the associated freezing temperature.")                    equilibrium_temperature = freezing_temperature_spline(P)                    state = reset_state(system, speciation_ratio_mol_kg, ReaktoroParams.SPECIES_CONCENTRATION_UNIT)            # If Pressure is >= PMax, Reaktoro is at its limits of computation and will likely fail. Thus, we utilize our spline approximation of freezing temperatures            # over a range of pressures that we are confident that Frezchem works at and find the associated freezing temperature at the given pressure.            # If the temperature we are querying over is less than that freezing temperature, then we assume its ice, otherwise we assume its liquid            else:                equilibrium_temperature = freezing_temperature_spline(P)            freezing_temperatures.append(equilibrium_temperature)            calculated_freezing_temperatures[P] = equilibrium_temperature        # Return the equilibrium temperature        return np.array(freezing_temperatures)"""def ice_freezing(aqueous_species_list, speciation_ratio_per_kg, P_MPa, T_K, PMax_MPa, TMin_K, TMax_K, freezing_temperatures_spline, frezchem_database, core_database, significant_threshold = 0.1):     Calculates whether ice is freezing at the given temperature and pressure. Utilizes the reaktoro framework to     constrain the equilibrium position at the prescribed pressure and temperature with the given composition,     and determines if ice has formed at a significant threshold of 1e-14, therefore calculating the phase of the solution     and returning true if the phase is ice and false if the phase is liquid.     Parameters     ----------     aqueous_species_list: aqueous species in reaction. Should be formatted in one long string with a space in between each species     speciation_ratio_per_kg: the ratio of species in the aqueous solution in mol/kg of water. Should be a dictionary     with the species as the key and its ratio as its value.     P_MPa (float, shape N): the desired equilibrium freezing pressure(s) in an array of size N.     T_K (float, shape N): the desired equilibrium freezing temperature(s) in an array of size N.     significant_threshold: the amount of moles of ice present for H2O to be considered in solid phase. Default is 1e-14 moles.     Returns     -------     ice_present (boolean, shape N): an array of true and falses that indicate whether for prescribed P_MPa and T_K coordinates        if there is ice present at significant threshold (default of 1e-14)    # Disable chemical convergence warnings that Reaktoro raises. We handle these internally instead and throw more specific warnings when they appear.    rkt.Warnings.disable(906)    # Create list that holds boolean values of whether ice is present    ice_present = []    # Create an iterator to go through P_MPa and T_K    it = np.nditer([P_MPa, T_K], flags =['multi_index'])    for P, T in it:        P = float(P)        T = float(T)        # Check that pressure is below PMax_MPa, the maximum pressure constraint calculated previously        if P <= PMax_MPa:            # Determine whether to use frezchem or core database based on temperature            if T < 298.15:                db, system, state, conditions, solver, props, ice_name, database_name = frezchem_database            else:                db, system, state, conditions, solver, props, ice_name, database_name = core_database            # Specify equilibrium conditions            conditions.pressure(P, "MPa")            conditions.temperature(T, "K")            # Solve the equilibrium problem            result = solver.solve(state, conditions)            # Update the properties            props.update(state)            # Check if the equilibrium problem succeeded            if result.succeeded():                # If so, obtain the total amount of solid H2O at equilibrium in moles                ice_amount = props.speciesAmount(ice_name)                # If the amount of solid H2O at equilibrium is > the significant threshold, then append true to the list, otherwise append false                ice_present.append(ice_amount > significant_threshold)                # Reset the state                state = reset_state(system, speciation_ratio_per_kg, ReaktoroParams.SPECIES_CONCENTRATION_UNIT)            # Otherwise, the equilibrium problem failed so we need to handle it accordingly            else:                # Warn the user about the failed equilibrium (good for debugging)                log.debug(                    f"Unsuccessful computation at: {props.pressure() / 1e+6} MPa and {props.temperature()} K.\n"                    f"The temperature and pressure may be out of bounds, but sometimes Reaktoro fails to converge on specific values even within bounds.\n"                    f"Will take an alternative approach of rerunning the equilibrium calculation by determining the temperature at which ice begins to forms at the given pressure and composition,\n"                    f"and if this temperature is below the freezing temperature then we will assume the state is solid, and if the temperature is above the freezing temperature then we will assume the state is liquid.")                # Instead, we will find the associated freezing temperature with the prescribed pressure and compare that freezing temperature to T                freezing_temperature = rkt_t_freeze(aqueous_species_list, speciation_ratio_per_kg, P, TMin_K,                                                    TMax_K, database_name, significant_threshold)                # If T is <= the freezing temperature for the given pressure, then we will assume ice is also present at this temperature and append True to list                # Otherwise, if T > the freezing temperature, we will assume ice is not present and append False to list                ice_present.append(T <= freezing_temperature)  # If T <= freezing_temperature, then we assume ice is present                # Reset the state                state = reset_state(system, speciation_ratio_per_kg, ReaktoroParams.SPECIES_CONCENTRATION_UNIT)        # If Pressure is >= PMax, Reaktoro is at its limits of computation and will likely fail. Thus, we utilize our spline approximation of freezing temperatures        # over a range of pressures that we are confident that Frezchem works at and find the associated freezing temperature at the given pressure.        # If the temperature we are querying over is less than that freezing temperature, then we assume its ice, otherwise we assume its liquid        else:            TFreezing_At_P = freezing_temperatures_spline(P)            ice_present.append(T < TFreezing_At_P)    # Convert the ice_present list into an array (of shape N) and return    ice_present = np.reshape(ice_present, P_MPa.shape)    return ice_present         """